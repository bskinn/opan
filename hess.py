<<<<<<< .mine
#-------------------------------------------------------------------------------
# Name:        hess
# Purpose:     Encapsulation of parsing/handling of data from Hessian files.
#
# Author:      Brian Skinn
#                bskinn@alum.mit.edu
#
# Created:     14 Nov 2014
# Copyright:   (c) Brian Skinn 2015
# License:     The MIT License; see "license.txt" for full license terms
#                   and contributor agreement.
#
#       This file is part of opan (OpenAnharmonic), a system for automated
#       computation of anharmonic properties of molecular systems via wrapper
#       calls to computational/quantum chemical software packages.
#
#       http://www.github.com/bskinn/opan
#
#-------------------------------------------------------------------------------

# Imports


# Debug constant
_DEBUG = False


class ORCA_HESS(object):
    """ Container for HESS data generated by ORCA.

    Information contained includes the Hessian matrix, the number of atoms,
    the atomic symbols, the atomic weights, and the geometry, as reported in
    the .hess file.  The precision of the geometry is less than that reported
    in an .xyz file, and thus should NOT be used for generation of subsequent
    computations.

    'N' in the below documentation refers to the number of atoms present in the
    geometry contained within the ENGRAD.

    Constructor may need to be adapted at some point in the future to handle
    construction from a custom storage container. For now, the file-based
    retrieval is the only implemented mode. If h5py turns out to be well
    suited for use as a repository format, such modification may not be
    necessary.

    Units of the Hessian are Hartrees per Bohr^2 (Eh/B^2)


    Instantiation
    -------------
    __init__(HESS_path)
        Constructor for an ORCA_HESS, drawing data from a HESS file on disk.

    Class Variables
    ---------------
    p_at_block      : re.compile() pattern
        RegEx for the entire block of atom ID & weight, and geom data.
    p_at_line       : re.compile() pattern
        RegEx for individual lines within the atom specification block
    p_hess_block    : re.compile() pattern
        RegEx for entire Hessian block
    p_hess_sec      : re.compile() pattern
        RegEx for a full-height, 3- or 6-column section of the Hessian
    p_hess_line     : re.compile() pattern
        RegEx for a single line within a Hessian section

    Instance Variables
    ------------------
    atom_masses     : N x 1 np.float_
        Column vector of atom masses as reported in HESS
    atom_syms       : N x 1 np.str
        Column vector of uppercase atomic symbols
    geom            : 3N x 1 np.float_
        Column vector of geometry [x1, y1, z1, x2, y2, ...]
    hess            : 3N x 3N np.float_
        Cartesian Hessian matrix
    HESS_path       : str
        Complete path/filename from which the Hessian data was retrieved
    initialized     : bool
        Flag for whether self has been initialized--possibly obsolete
    in_str          : str
        Complete contents of the imported HESS file
    num_ats         : int
        Number of atoms in the system

    Methods
    -------
    check_geom(coords, atoms[, tol])
        Checks vectors of atom coordinates and identities for consistency
        with the geometry and atom identities stored within the instance of
        ORCA_HESS.

    Generators
    ----------
    (none)
    """

    # Imports
    import re
    from .const import DEF


    # Various class-level RegEx patterns.  Currently only retrieves the
    #  atom list and the Hessian itself. No other information in the .hess file
    #  is actually explicitly needed at present (will be recomputed internally)
    #  and so there's little point to spending time coding imports for it.

    # Atoms list, including atomic weights. Assumes no scientific notation
    #  will be used in the coordinates.
    p_at_block = re.compile("""
    \\#.*\\n                        # Line prior to $atoms is a blank comment
    \\$atoms.*\\n                   # $atoms indicator for start of block
    (?P<num>[0-9]+).*               # Storing the number of atoms
    (?P<block>\\n                   # Store the whole chunk of coordinates
        (                           # Open group for atom lines def
            [ \\t]+([a-z]+|[0-9]+)  # Whitespace and atomic number/element
            [ \\t]+[0-9.]+          # Whitespace and atomic mass
            (                       # Open group for coordinates
                [ \\t]+[0-9.-]+     # Whitespace and one coordinate
            ){3}                    # Three coordinates for each line
            .*\\n                   # Whatever to end of line
        )+                          # Some number of coordinate lines
    )                               # Close the "block" group
    """, re.I | re.M | re.X)

    # Pulling the individual atoms, weights, and coordinates from each atom line
    p_at_line = re.compile("""
    ^[ \\t]+                        # Whitespace to start the line
    (?P<el>([a-z]+|[0-9]+))         # Atomic number or element symbol
    [ \\t]+(?P<mass>[0-9.]+)        # Whitespace and atomic mass
    [ \\t]+(?P<c1>[0-9.-]+)         # Whitespace and first coordinate
    [ \\t]+(?P<c2>[0-9.-]+)         # Whitespace and second coordinate
    [ \\t]+(?P<c3>[0-9.-]+)         # Whitespace and third coordinate
    """, re.I | re.M | re.X)

    # Entire Hessian data block
    p_hess_block = re.compile("""
    \\$hessian.*\\n                 # Marker for Hessian block
    (?P<dim>[0-9]+).*\\n            # Dimensionality of Hessian (N x N)
    (?P<block>                      # Group for the subsequent block of lines
        (                           # Group for single line definition
            ([ \\t]+[0-9.-]+)+      # Some number of whitespace-separated nums
            .*\\n                   # Plus whatever to end of line
        )+                          # Whatever number of single lines
    )                               # Enclose the whole batch of lines
    """, re.I | re.X)

    # Sections of the Hessian data block
    p_hess_sec = re.compile("""
    ([ \\t]+[0-9]+)+[ \\t]*\\n      # Column header line
    (                               # Open the group for the sub-block lines
        [ \\t]+[0-9]+               # Row header
        (                           # Open the group defining a single element
            [ \\t]+[-]?             # Whitespace and optional hyphen
            [0-9]+\\.[0-9]+         # One or more digits, decimal, more digits
        )+                          # Some number of sub-columns
        [ \\t]*\\n                  # Whitespace to EOL
    )+                              # Some number of suitable lines
    """, re.I | re.X)

    # Pulling Hessian lines from the sections, with elements in groups
    p_hess_line = re.compile("""
    ^[ \\t]*                        # Optional whitespace to start each line
    (?P<row>[0-9]+)                         # Row header
    [ \\t]+(?P<e0>[0-9-]+\\.[0-9]+)         # 1st element
    [ \\t]+(?P<e1>[0-9-]+\\.[0-9]+)         # 2nd element
    [ \\t]+(?P<e2>[0-9-]+\\.[0-9]+)         # 3rd element
    ([ \\t]+(?P<e3>[0-9-]+\\.[0-9-]+))?     # 4th element (possibly absent)
    ([ \\t]+(?P<e4>[0-9-]+\\.[0-9-]+))?     # 5th element (possibly absent)
    ([ \\t]+(?P<e5>[0-9-]+\\.[0-9-]+))?     # 6th element (possibly absent)
    .*$                             # Whatever to end of line
    """, re.I | re.M | re.X)

    def __init__(self, HESS_path):
        """ Initialize ORCA_HESS Hessian object from .hess file

        Searches indicated file for geometry and Hessian block. Currently
        does *not* retrieve any of the other information stored in a .hess
        file.

        In future, will likely require extension to handle import from some
        manner of custom object, in order to implement saving/loading of
        anharmonic computations.


        Parameters
        ----------
        HESS_path : string
            Complete path to the .hess file to be read.

        Raises
        ------
        HESSError   : If indicated Hessian file is malformed in some fashion
        ValueError  : If displacement mode, direction or magnitude are invalid
        TypeError   : If any displacement flag is of an incorrect type
        IOError     : If the indicated file does not exist or cannot be read
        """

        # Imports
        import numpy as np
        from .error import HESSError
        from .utils import safe_cast as scast
        from .const import atomNum, atomSym

        # Set the initialization flag (possibly unnecessary...)
        self.initialized = False

        # Open file, read contents, close stream
        # No particular exception handling; that will be the responsibility
        #  of the calling routine.
        # May want to add a check for text file format; but, really, a check
        #  for expected-information-not-found will likely cover such a case.
        with open(HESS_path,'rU') as in_fl:
            self.in_str = in_fl.read()
        ## end with

        # Store the path used to retrieve the data
        self.HESS_path = HESS_path

        # Check to ensure all relevant data blocks are found
        if not ORCA_HESS.p_at_block.search(self.in_str):
            raise(HESSError(HESSError.at_block,
                    "Atom specification block not found",
                    "HESS File: " + HESS_path))
        ## end if
        if not ORCA_HESS.p_hess_block.search(self.in_str):
            raise(HESSError(HESSError.hess_block,
                    "Hessian block not found",
                    "HESS File: " + HESS_path))
        ## end if

        # Bring in the number of atoms
        self.num_ats = np.int_( \
                ORCA_HESS.p_at_block.search(self.in_str).group("num"))

        # Initialize the vectors of atomic symbols, masses, and the
        #  geometry
        self.atom_syms = []
        self.atom_masses = []
        self.geom = []

        # Parse the list of atoms
        for m in ORCA_HESS.p_at_line.finditer( \
                ORCA_HESS.p_at_block.search(self.in_str).group("block")):
            # Parse the element symbol or atomic number
            try:
                # See if it casts as an int
                num = scast(m.group('el'), np.int_)
            except ValueError, TypeError:
                # Nope, must be letters. Check if valid by poking it into the
                #  dict. If not valid, should raise another error.
                num = atomNum[str.upper(m.group('el'))]
            ## end try

            # If this point is reached, either it's cast ok to an int,
            #  or the string has been passed through the atomNum dict and
            #  is a valid element symbol. SO, convert back to atomSym and
            #  store - this will also check for an invalid int entry
            self.atom_syms.append(atomSym[num])

            # Parse the atomic weight; should be a simple append?
            self.atom_masses.append(scast(m.group("mass"), np.float_))

            # Build geometry as a 1-D list
            for gp in ["c1", "c2", "c3"]:
                self.geom.append(scast(m.group(gp), np.float_))
            ## next gp

        # Double-check that the number of atoms retrieved matches the
        #  number indicated in the HESS file; geometry size also.
        if not len(self.atom_syms) == self.num_ats:
            raise(HESSError(HESSError.at_block, "Atomic symbol dimension " + \
                    "mismatch with HESS atom specification", \
                    "HESS File: " + HESS_path))
        ## end if
        if not len(self.atom_masses) == self.num_ats:
            raise(HESSError(HESSError.at_block, "Atomic mass dimension " + \
                    "mismatch with HESS atom specification", \
                    "HESS File: " + HESS_path))
        ## end if
        if not len(self.geom) == 3 * self.num_ats:
            raise(HESSError(HESSError.at_block, "Geometry dimension " + \
                    "mismatch with HESS atom specification", \
                    "HESS File: " + HESS_path))
        ## end if

        # Convert instance variables to numpy storage forms
        self.atom_syms = np.vstack(self.atom_syms)
        self.atom_masses = np.vstack(np.array(self.atom_masses, \
                                dtype=np.float_))
        self.geom = np.vstack(np.array(self.geom, dtype=np.float_))

        # Now to import the Hessian matrix; error if not found
        m_hess_block = ORCA_HESS.p_hess_block.search(self.in_str)
        if m_hess_block == None:
            raise(HESSError(HESSError.hess_block, "No match for Hessian " + \
                    "block found", \
                    "HESS File: " + HESS_path))
        ## end if

        # Confirm the anticipated Hessian size matches 3*num_ats
        if not int(m_hess_block.group("dim")) == 3*self.num_ats:
            raise(HESSError(HESSError.hess_block, "Hessian dimension " + \
                    "mismatch with geometry", \
                    "HESS File: " + HESS_path))
        ## end if

        # Initialize the Hessian matrix
        self.hess = np.zeros((3*self.num_ats, 3*self.num_ats), dtype=np.float_)

        # Initialize the column offset for populating the Hessian
        col_offset = 0

        # Loop through the subsections of the Hessian
        for m_hess_sec in ORCA_HESS.p_hess_sec \
                                    .finditer(m_hess_block.group("block")):
            # Loop through each entry
            for m_hess_line in ORCA_HESS.p_hess_line \
                                    .finditer(m_hess_sec.group(0)):
                # Store the row; base zero in .HESS so no adjustment needed.
                rowval = scast(m_hess_line.group("row"), np.int_)

                # Loop to fill the row
                for i in range(6):
                    # Store the element
                    val = scast(m_hess_line.group('e' + str(i)), np.float_)

                    # Only store to Hessian if a value actually retrieved.
                    #  This protects against the final three-column section in
                    #  Hessians for systems with an odd number of atoms.
                    if not np.isnan(val):
                        self.hess[rowval, col_offset + i] = val
                    ## end if
                ## next i

            # Last thing is to increment the offset by six. Don't have to
            #  worry about offsetting for a section only three columns wide
            #  because that SHOULD only ever occur at the last section
            col_offset += 6
        ## next m_hess_sec

        # Check to ensure that the column offset is high enough to have
        #  fully populated the Hessian based on the number of atoms. This is a
        #  check against malformation of the HESS file, resulting in a reduced
        #  number of sections being retrieved.
        if not col_offset >= (3 * self.num_ats):
            raise(HESSError(HESSError.hess_block, "Insufficient number of " + \
                    "HESS sections found", \
                    "HESS File: " + HESS_path))
        ## end if

        # Set initialization flag; probably unnecessary?
        self.initialized = True

    ## end def __init__


    def check_geom(self, coords, atoms, tol=DEF.HESS_Coord_Match_Tol):
        """ Check for consistency of HESS geometry with input coords/atoms.

        HESS cartesian coordinates are considered consistent with the input
            coords if each component matches to within 'tol' (default value
            specified by orca_const.DEF.HESS_Coord_Match_Tol).  If coords or
            atoms vectors are passed that are of different length than those
            stored in the ORCA_ENGRAD instance, a False value is returned.

        The coords vector must be three times the length of the atoms vector
            or a ValueError is raised.

        Parameters
        ----------
        coords : 3N x 1 float
            Vector of stacked 'lab-frame' Cartesian coordinates
        atoms  : N x 1 string or int
            Vector of atom symbols or atomic numbers
        tol    : float, optional
            Tolerance for acceptable deviation of each geometry coordinate
            from that in the ORCA_HESS instance to still be considered
            matching

        Returns
        -------
        match  : bool
            Whether input coords and atoms match those in the ORCA_ENGRAD
            instance (True) or not (False)
        fail_type  : string
            If match == False, a string description code for the reason
            for the failed match:
                coord_dim_mismatch  : Mismatch in coordinate vector sizes
                atom_dim_mismatch   : Mismatch in atom symbol vector sizes
                coord_mismatch      : Mismatch in one or more coordinates
                atom_mismatch       : Mismatch in one or more atoms
                #DOC: Propagate info when mismatch code converted to Enum
        fail_loc   : 3N x 1 bool or N x 1 bool
            np.matrix() column vector indicating positions of mismatch in
            either coords or atoms, depending on the value of fail_type.
            True elements indicate corresponding *MATCHING* values; False
            elements mark *MISMATCHES*.

        Raises
        ------
        ValueError : If len(coords) != 3 * len(atoms)
        """

        # Import(s)
        from .utils import check_geom as ucg

        # Wrapper call
        result = ucg(self.geom, self.atom_syms, coords, atoms, tol=tol)

        # Return result
        return result

    ## end def check_geom


if __name__ == '__main__':
    print("Module not executable.")
||||||| .r0
=======
# Blank thing
>>>>>>> .r2
