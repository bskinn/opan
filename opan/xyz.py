#-------------------------------------------------------------------------------
# Name:        xyz
# Purpose:     Encapsulation of parsing/handling of data from OpenBabel-type
#                molecule geometry files.
#
# Author:      Brian Skinn
#                bskinn@alum.mit.edu
#
# Created:     13 Aug 2014
# Copyright:   (c) Brian Skinn 2015
# License:     The MIT License; see "license.txt" for full license terms
#                   and contributor agreement.
#
#       This file is part of opan (OpenAnharmonic), a system for automated
#       computation of anharmonic properties of molecular systems via wrapper
#       calls to computational/quantum chemical software packages.
#
#       http://www.github.com/bskinn/opan
#
#-------------------------------------------------------------------------------

# Imports


# Debug constant
_DEBUG = False


class OPAN_XYZ(object):
    """ Container for OpenBabel XYZ data.

    Contains all geometries present in the OpenBabel file at the path passed
    to __init__ if initialized with the 'path' keyword argument, or contains
    a single geometry if initialized with the 'atom_syms' and 'coords' keyword
    arguments.

    'N' and 'G' in the below documentation refer to the number of atoms per
    geometry and the number of geometries present in the file, respectively.
    Note that *ALL* geometries present *MUST* contain the same number of atoms,
    and must all *FALL IN THE SAME SEQUENCE* of elements. The class and
    functions won't complain if positions of like atoms are swapped, but this
    will almost certainly cause trouble in downstream code.

    Initializer can be called in one of two forms:

        OPAN_XYZ(path='path/to/file')
        OPAN_XYZ(atom_syms={array of atoms}, coords={array of coordinates})

    In both forms, the optional keyword argument 'bohrs' can be specified, to
    indicate the units of the coordinates as Bohrs (True) or Angstroms (False).
    Angstrom and Bohr units are the default for the first and second forms,
    respectively. The units of all coordinates stored in the instance are
    *Bohrs*.

    For reference, in ORCA XYZ files contain the highest precision geometry
    information of any output save perhaps the textual output generated by
    the program, and are stored in Angstrom units.

    Instantiation
    -------------
    (see above)

    Class Variables
    ---------------
    p_coords    : re.compile() pattern
        RegEx for single, full blocks of coordinates
    p_geom      : re.compile() pattern
        RegEx for lines of coordinates within a geometry block

    Instance Variables
    ------------------
    XYZ_path    : str
        Full path to imported OpenBabel file
    atom_syms   : str list, len(N)
        Atomic symbols for the atoms
    descs       : str list, len(G)
        Text descriptions for each geometry included in the file
    geoms       : len(G) list of len(3N) np.arrays of np.float_
        Molecular geometry/geometries, stored as a list of 3N-vectors
    in_str      : str
        Complete contents of input file
    initialized : bool
        Flag for whether instance has already been constructed
    num_atoms   : int
        Number of atoms per geometry, N
    num_geoms   : int
        Number of geometries found, G

    Methods
    -------
    Geom_single(g_num)
        Return the length-3N np.array of geometry with index 'g_num'
    Displ_single(g_num, at_1, at_2)
        Return the vector displacement from at_1 toward at_2 as a length-3
        np.array, in Bohr units
    Dist_single(g_num, at_1, at_2)
        Return the Euclidean distance between atoms with indices 'at_1' and
        'at_2' for geometry 'g_num' in Bohr units
    Angle_single(g_num, at_1, at_2, at_3)
        Return the bond angle at_1 --> at_2 --> at_3 for geometry 'g_num' in
        degrees. at_2 must be distinct from both at_1 and at_3.
    Dihed_single(g_num, at_1, at_2, at_3, at_4)
        Return the dihedral angle at_1 --> at_2 --> at_3 --> at_4 in degrees
        for geometry 'g_num'. See the function docstring for more details and
        restrictions on atom indices and structural parameters.

    Generators
    ----------
    == In all of the below, each parameter can either be an iterable of     ==
    == indices or a single index. If more than one parameter is an iterable ==
    == then they all must have the same length 'N'.  The generator will     ==
    == iterate over each set of indices from 1 to N, taking each iterable   ==
    == value once, and using any single-index parameters in each case.      ==
    ==                                                                      ==
    == Exactly one argument in these functions can also be specified as     ==
    == None, in which case all other arguments must be non-iterables. In    ==
    == this case, the None will be transformed into an iterable spanning    ==
    == the full range of valid values for that argument.                    ==
    Geom_iter(g_nums)
        Iterate over the geometries specified by the indices 'g_nums'
    Displ_iter(g_nums, ats_1, ats_2)
        Iterate over a series of displacements.
    Dist_iter(g_nums, ats_1, ats_2)
        Iterate over a series of Euclidean distances
    Angle_iter(g_nums, ats_1, ats_2, ats_3)
        Iterate over a series of bond angles
    Dihed_iter(g_nums, ats_1, ats_2, ats_3, ats_4)
        Iterate over a series of dihedral angles

    """

    # Imports
    import re as _re
    from .utils.decorate import arraysqueeze as _arraysqueeze

    # Class constants
    LOAD_DATA_FLAG = "DATA"

    # Define the RegEx to pull entire geometry blocks
    # re.M is required in order for the "^" at the start of the pattern
    #  to match more than just the first geometry block in a file
    # The "[^\\n\\w]" pattern is a weak equivalent of \\s, made necessary
    #  since \\s *includes* \\n.
    # Perhaps "[ \\t]" will suffice...
    p_geom = _re.compile("""
    ^(?P<num>\\d+)      # Integer number of atoms
    [ \\t]*\\n          # Whitespace scrub to end of line
    (?P<desc>[^\\n]+)   # Geometry description
    \\n                 # Newline to end geometry description
    (?P<coord>          # Open group for entire set of atom coords
        (                   # Open group for one coord line
            [ \\t]*?            # Any whitespace before element
            ([a-z]+|\\d+)       # Element name or atomic #
            (                   # Open group for coord value
                [ \\t]+?            # Any whitespace before coord value
                [0-9.-]+            # Decimal coordinate value
            ){3}                # Three coordinates to retrieve
            [ \\t]*\\n          # Any whitespace to end of line
        )+                  # Close one coord line group; should be >= 1
    )                   # Close group for entire set of atom coords
    """, _re.I | _re.X | _re.M)

    # Define the RegEx to pull individual lines from the coordinate block
    #  retrieved by the p_geom RegEx.
    # As w/p_geom, re.M is required for "^" to match the start of each line of
    #  the coords block.
    p_coords = _re.compile("""
    ^[ \\t]*?               # Any whitespace before element id
    (?P<el>([a-z]+|\\d+))   # Element ID, symbol or atomic number
    [ \\t]+?                # Whitespace before first coordinate
    (?P<c1>[0-9.-]+)        # First coordinate
    [ \\t]+?                # Whitespace before second coordinate
    (?P<c2>[0-9.-]+)        # Second coordinate
    [ \\t]+?                # Whitespace before third coordinate
    (?P<c3>[0-9.-]+)        # Third coordinate
    """, _re.I | _re.X | _re.M)


    def __init__(self, **kwargs):
        """ Initialize XYZ data from file or existing geometry.

        Initializer can be called in one of two forms:

        OPAN_XYZ(path='path/to/file')
        OPAN_XYZ(atom_syms={array of atoms}, coords={array of coordinates})

        In both forms, the optional keyword argument 'bohrs' can be specified,
        to indicate the units of the coordinates as Bohrs (True) or
        Angstroms (False). Angstrom and Bohr units are the default for the
        first and second forms, respectively. The units of all coordinates
        stored in the instance are *Bohrs*, regardless of this setting.
        """

        # Two situations. One should have 'path' and, optionally, 'bohrs'
        #  specified (default here is Angstroms). The other needs an N x 1
        #  'atom_syms' vector and a 3N x 1 'coords' vector.
        if 'path' in kwargs:
            # All set for load from file. 'bohrs' defaults False here
            self._load_file(kwargs['path'], \
                    bohrs=(kwargs['bohrs'] if 'bohrs' in kwargs else False))
        else:
            # Look for the from-coordinates objects
            if all([(k in kwargs) for k in ('atom_syms', 'coords')]):
                # Found. Call the by-data initializer. 'bohrs' defaults to
                #  TRUE here (presume main call is from repo)
                self._load_data(kwargs['atom_syms'], \
                        kwargs['coords'], \
                        bohrs=(kwargs['bohrs'] if 'bohrs' in kwargs else True))
            else:
                # NOT found -- error!
                raise(NameError("Insufficient named parameters found"))
            ## end if
        ## end if

    ## end def __init__


    @_arraysqueeze(1,2)
    def _load_data(self, atom_syms, coords, bohrs=True):
        """ Internal function for making XYZ object from explicit geom data.

        Parameters
        ----------
        atom_syms   : squeezes to array of N strings
            Element symbols for the XYZ. Must be valid elements as defined in
            .const.atomNum.keys()
        coords      : squeezes to array of 3N np.float_ castables
            Coordinates for the geometry (x1, y1, z1, x2, y2, ...)
        bohrs       : bool, default True
            Units of coordinates

        Raises
        ------
        XYZError    : If ORCA_XYZ object has already been initialized
        ValueError  : If atom_syms & coords dimensions are incompatible
        ValueError  : If types of atom_syms or coords are invalid
        """

        # Imports
        import numpy as np
        from .const import atomNum
        from .error import XYZError

        # Gripe if already initialized
        if 'initialized' in dir(self):
            raise(XYZError(XYZError.overwrite, \
                    "Cannot overwrite contents of existing OPAN_XYZ", ""))
        ## end if

        # Check and store dimensions
        if not len(coords.shape) == 1:
            raise(ValueError("Coordinates are not a vector"))
        ## end if
        if not len(atom_syms.shape) == 1:
            raise(ValueError("Atom symbols are not a simple list"))
        ## end if
        if not coords.shape[0] == 3 * atom_syms.shape[0]:
            raise(ValueError("len(coords) != 3 * len(atom_syms)"))
        ## end if

        # Proof the atoms list
        if not all([(atom_syms[i].upper() in atomNum) \
                                for i in range(atom_syms.shape[0])]):
            # Invalid atoms specified
            raise(ValueError("Invalid atoms specified: " + str( \
                    [(j, atom_syms[j]) for j in \
                        [i for i, valid in \
                            enumerate(map( \
                                        lambda k: k in atomNum, \
                                        atom_syms)) \
                            if not valid \
                        ] \
                    ] )))
        ## end if

        # Ensure the geometry is all numeric
        if not all(map(np.isreal, coords)):
            raise(ValueError("All coordinates must be real numeric"))
        ## end if

        # Store the number of atoms. Only one geometry. Standard string
        #  content for things only relevant to file load.
        self.num_atoms = atom_syms.shape[0]
        self.num_geoms = 1
        self.in_str = self.LOAD_DATA_FLAG
        self.descs = np.array([self.LOAD_DATA_FLAG])
        self.XYZ_path = self.LOAD_DATA_FLAG

        # Store the atoms as vector
        self.atom_syms = map(str.upper, list(atom_syms))

        # Store the single geometry by bracketing with an array
        self.geoms = [coords]

        self.initialized = True

    ## end def _load_data


    def _load_file(self, XYZ_path, bohrs=False):
        """ Initialize OPAN_XYZ geometry object from OpenBabel file

        Import of an arbitrary number of multiple geometries from an OpenBabel
        file. All geometries must have the same number and type of atoms,
        and the ordering of atom types must be retained throughout.

        Parameters
        ----------
        XYZ_path : string
            Complete path to the .xyz / .trj file to be read
        bohrs    : bool, optional
            Flag for whether coordinates are interpreted as in Bohrs or
            Angstroms. Default is False = Angstroms.

        Raises
        ------
        XYZError : If indicated geometry file is malformed in some fashion
        IOError  : If the indicated file does not exist or cannot be read
        """

        # Imports
        import numpy as np
        from .const import CIC, PHYS, atomNum, atomSym
        from .error import XYZError
        from .utils import safe_cast as scast

        # Complain if already initialized
        if 'initialized' in dir(self):
            raise(XYZError(XYZError.overwrite, \
                    "Cannot overwrite contents of existing OPAN_XYZ", ""))
        ## end if

        # Open file, read contents, close stream
        # No particular exception handling; that will be the responsibility
        #  of the calling routine.
        # May want to add a check for text file format; but, really, a check
        #  for no-found-geometry-information will likely cover such a case.
        with open(XYZ_path,'rU') as in_fl:
            self.XYZ_path = XYZ_path
            self.in_str = in_fl.read()

        # Check to ensure at least one geom match; else raise some sort of
        #  error
        if not OPAN_XYZ.p_geom.search(self.in_str):
            raise(XYZError(XYZError.xyzfile,
                    "No valid geometry found",
                    "XYZ file: " + XYZ_path))
        ## end if

        # Store the number of atoms. XYZ files with multiple geometries will
        #  be required to have the same number of atoms in all geometries.
        #  This is fine for OpenAnharmonic, but may be highly undesirable
        #  in other applications.  Beware.
        # If the .match() call doesn't have a group attribute, catch the
        #  resulting AttributeError and throw an XYZError. Can't think of any
        #  other situation that would throw an AttributeError here, so probably
        #  I don't have to check for a subtype of AttributeError...
        # Can't think of a need for an else or a finally here
        try:
            self.num_atoms = scast(OPAN_XYZ.p_geom.match(self.in_str)
                                            .group("num"), np.int_)
        except AttributeError:
            raise(XYZError(XYZError.xyzfile,
                    "No geometry block found at start of file",
                    "XYZ file: " + XYZ_path))
        ## end try

        # Initialize the description vector and geometry array
        # CANNOT use matrix type for the geometry since it's 3D.
        # Retriever function for geometry should convert the given slice
        #  to a vector as an np.matrix, though.
        # Geometry is constructed as a length-3N vector of
        #  coordinates, where atom 1's x/y/z coordinates are sequential,
        #  then atom 2's x/y/z coordinates are sequential, etc.
        # Multiple geometries in a single XYZ file are stacked in a simple
        #  array.
        self.descs = []
        self.geoms = []

        # Initialize the atom symbols vector
        self.atom_syms = []

        # Define a counter for the number of geometries. Store as a persistent
        #  instance variable because it will be useful later.
        self.num_geoms = 0

        # Loop over the geometry blocks found in the input file
        for mch in OPAN_XYZ.p_geom.finditer(self.in_str):
            # Check that the number of atoms is consistent with the spec
            #  found in the first geometry block
            if not scast(mch.group("num"), np.int_) == self.num_atoms:
                raise(XYZError(XYZError.xyzfile,
                        "Non-constant number of atoms in multiple geometry",
                        "XYZ file: " + XYZ_path))
            ## end if

            # Store the description for the current geometry
            self.descs.append(mch.group("desc"))

            # Assemble the coordinates vector and assemble/check the element
            #  ID vector.
            # Reset the atom counter and the coordinates vector
            atom_count = 0
            coord_vec = np.empty((0,),dtype=np.float_)
            for line_mch in OPAN_XYZ.p_coords.finditer(mch.group("coord")):
                # Check for whether element list has been fully populated
                if len(self.atom_syms) < self.num_atoms:
                    # If not, continue populating it; have to check for
                    #  whether it's an atomic number or an element symbol
                    if line_mch.group("el").isdigit():
                        # Atomic number
                        # Check for valid number
                        at_num = scast(line_mch.group("el"), np.int_)
                        if not (at_num >= CIC.Min_Atomic_Num and
                                    at_num <= CIC.Max_Atomic_Num):
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is an unsupported element",
                                     "XYZ file: " + XYZ_path))
                        ##end if

                        # Tag on the new symbol
                        self.atom_syms.append(atomSym[at_num])
                    else:
                        # Element symbol; store as all caps
                        # Check for valid element, first by catching if the
                        #  specified element string is even valid
                        try:
                            at_num = atomNum[line_mch.group("el").upper()]
                        except KeyError:
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is an unrecognized element",
                                     "XYZ file: " + XYZ_path))
                        ## end try

                        # Tag on the new symbol
                        self.atom_syms.append(line_mch.group("el").upper())
                    ## end if
                else: # List is fully populated
                    # If so, confirm that the element specified at the current
                    #  line matches that of the first geometry of the file
                    # Have to check whether it's an atomic number or symbol.
                    if line_mch.group("el").isdigit():
                        # Atomic number; don't need safe cast; must trap for
                        #  a bad atomic number
                        at_num = scast(line_mch.group("el"), np.int_)
                        if not (at_num >= CIC.Min_Atomic_Num and
                                    at_num <= CIC.Max_Atomic_Num):
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is an unsupported element",
                                     "XYZ file: " + XYZ_path))
                        ## end if
                        if not atomSym[at_num] == self.atom_syms[atom_count]:
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is inconsistent with geometry #0",
                                     "XYZ file: " + XYZ_path))
                        ## end if

                    else:
                        # Element symbol
                        # Check for valid element, first by catching if the
                        #  specified element string is even valid
                        try:
                            at_num = atomNum[line_mch.group("el").upper()]
                        except KeyError:
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is an unrecognized element",
                                     "XYZ file: " + XYZ_path))
                        ## end try
                        # Confirm symbol matches the initial geometry
                        if not line_mch.group("el").upper() == \
                                                self.atom_syms[atom_count]:
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is inconsistent with geometry #0",
                                    "XYZ file: " + XYZ_path))
                        ## end if
                    ## end if
                ## end if

                # Append the three coordinates of the current atom to the
                #  temp coordinates vector, converting to Bohrs if indicated.
                # Working in Bohrs is desired because they are atomic units
                #  and thus are part of the internal unit definition of the
                #  Hartree.
                for c_str in range(1,4):
                    coord_vec = np.concatenate(
                            (coord_vec, [
                        scast(line_mch.group("c" + str(c_str)), np.float_) /
                        (1.0 if bohrs else PHYS.Ang_per_Bohr)
                                        ]), axis=0)
                ## next c_str

                # Increment the atom_count for the atom number
                atom_count += 1

            ## next line_mch

            # Confirm that number of imported coordinates matches the
            #  number expected from self.num_atoms
            if not coord_vec.shape[0] == 3*self.num_atoms:
                raise(XYZError(XYZError.xyzfile,
                        "Geometry #" + str(self.num_geoms)+
                        " atom count is inconsistent",
                        "XYZ file: " + XYZ_path))
            ## end if

            # Assemble the coordinates vector into the actual coordinates
            #  stack for the XYZ
            self.geoms.append(coord_vec)

            # Increment the count of the number of geometries. Once the
            #  'mch' iteration is completed, this will accurately reflect
            #  the number of geometries read from the file.
            self.num_geoms += 1

        ## next mch

        # Set the internal initialization flag
        self.initialized = True

    ## end def _load_file


    def Geom_single(self, g_num):
        """ Retrieve a single geometry from the OPAN_XYZ instance.

        The atom coordinates are returned as a length-3N np.array,
            with each atom's x/y/z coordinates returned together:
            [A1x,A1y,A1z,A2x,A2y,A2z,...]

        Parameters
        ----------
        g_num : int
            Index of the desired geometry (base 0)

        Returns
        -------
        geom : length-3N np.array
            Vector of the atomic coordinates for the geometry indicated
            by 'g_num'

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num is provided
        """

        # Just return the appropriate geometry vector
        geom = self.geoms[g_num]
        return geom

    ## end def Geom_single


    def Geom_iter(self, g_nums):
        """Iterator over selected geometries from the OPAN_XYZ instance.

        The indices of the geometries to be returned are indicated by an
            iterable of integers passed as g_nums.

        Each set of atom coordinates is returned as a numpy.matrix column
            vector, with each atom's x/y/z coordinates returned together:
            [A1x,A1y,A1z,A2x,A2y,A2z,...]

        Parameters
        ----------
        g_nums : (N) iterable int
            Indices of the desired geometries for iteration (base 0)

        Generates
        ---------
        geom : length-3N np.arrays
            Length-3N vectors of the atomic coordinates for each geometry
            indicated by 'g_nums'

        Raises
        ------
        IndexError : If an invalid (out-of-range) entry of g_nums is provided
        ValueError :  (via .utils.pack_tups) If all iterable objects are
            not the same length
        """
        # Using the custom coded pack_tups to not have to care whether the
        #  input is iterable
        from .utils import pack_tups

        vals = pack_tups(g_nums)
        for val in vals:
            yield self.Geom_single(val[0])

    ## end def Geom_iter


    def Dist_single(self, g_num, at_1, at_2):
        """ Retrieve an interatomic distance from the OPAN_XYZ instance.

        Returns the interatomic distance between the two atoms at_1 and at_2
            from geometry g_num in Bohrs.

        Parameters
        ----------
        g_num : int
            Index of the desired geometry (base 0)
        at_1 : int
            Index of the first atom (base 0)
        at_2 : int
            Index of the second atom (base 0)

        Returns
        -------
        dist : np.float_
            Interatomic distance in Bohrs between atoms at_1 and at_2 from
            geometry g_num

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num, at_1 or at_2
            is provided
        """
        # Import used math library function(s)
        import numpy as np
        from scipy import linalg as spla
        from .utils import safe_cast as scast

        # The below errors are explicitly thrown since values are multiplied by
        #  three when they are used as an index and thus give non-intuitive
        #  errors in subsequent code.
        # Complain if at_1 is invalid
        if at_1 < -self.num_atoms or at_1 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_1' (" + str(at_1) + ")"))

        # Complain if at_2 is invalid
        if at_2 < -self.num_atoms or at_2 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_2' (" + str(at_2) + ")"))

        # Should never be necessary (save for badly erroneous calling code),
        #  but coerce at_1 and at_2 to their floor() values.  This is again
        #  needed since they are multiplied by three in the index expresssions
        #  below, and can cause funny behavior when truncated by the indexing
        at_1 = scast(np.floor(at_1), np.int_)
        at_2 = scast(np.floor(at_2), np.int_)

        # Calculate the interatomic distance and return. Return identically
        #  zero if the indices are equal
        if at_1 == at_2:
            dist = 0.0
        else:
            dist = scast( \
                    spla.norm(self.Displ_single(g_num, at_1, at_2)), \
                            np.float_)
        ## end if

        return dist

    ## end def Dist_single


    def Dist_iter(self, g_nums, ats_1, ats_2, invalid_error=False):
        """ Iterator over selected interatomic distances.

        Returns the interatomic distances between the two atom sets ats_1 and
            ats_2 from geometries g_nums in Bohrs.

        Any of ats_1, ats_2 and g_nums can be either a single index or an
            iterable; any iterables must all be the same length.
            Alternatively, exactly one parameter can be None and all other
            parameters single indices, in which case the full valid range of
            the `None` parameter is used.

        Parameters
        ----------
        g_nums : int or iterable int or None
            Index/indices of the desired geometry/geometries (base 0)
        ats_1 : int or iterable int or None
            Index/indices of the first atom(s) (base 0)
        ats_2 : int or iterable int or None
            Index/indices of the second atom(s) (base 0)
        invalid_error  : bool, default False
            If False, 'None' values are returned for results corresponding to
            invalid indices. If True, exceptions are raised per normal.

        Returns
        -------
        dist : np.float64 (generator)
            Interatomic distance in Bohrs between each atom pair of ats_1 and
            ats_2 from the corresponding geometries of g_nums.

        Raises
        ------
        IndexError :  (via Dist_single) If any parameter value is out of range
        ValueError :  (via .utils.pack_tups) If all iterable objects are
            not the same length
        """

        # Imports
        import numpy as np
        from .utils import pack_tups

        # Print the function inputs if debug mode is on
        if _DEBUG:  # pragma: no cover
            print("g_nums = " + str(g_nums))
            print("ats_1 = " + str(ats_1))
            print("ats_2 = " + str(ats_2))
        ## end if

        # Perform the None substitution
        arglist = self._None_subst(g_nums, ats_1, ats_2)

        # Expand/pack the tuples from the inputs
        tups = pack_tups(*arglist)

        # Dump the results if debug mode is on
        if _DEBUG:  # pragma: no cover
            print(tups)
        ## end if

        # Construct the generator using the packed tuples. If 'None' expansion
        #  was used, return None for any invalid indices instead of raising
        #  an exception.
        for tup in tups:
            yield self._iter_return(tup, self.Dist_single, invalid_error)
        ## next tup

    ## end def Dist_iter


    def Angle_single(self, g_num, at_1, at_2, at_3):
        """ Retrieve an atomic angle from the OPAN_XYZ instance.

        Returns the angle between three atoms at_1, at_2 and at_3
            from geometry g_num in degrees, with at_2 the central atom.

        The indices at_1 and at_3 can be the same (yielding a trivial zero
            angle), but at_2 must be different from both at_1 and at_3.

        Parameters
        ----------
        g_num : int
            Index of the desired geometry (base 0)
        at_1 : int
            Index of the first atom (base 0)
        at_2 : int
            Index of the second atom (base 0)
        at_3 : int
            Index of the third atom (base 0)

        Returns
        -------
        angle : np.float64
            Atomic angle in degrees between atoms at_1-at_2-at_3, from
            geometry g_num

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num, or at_n is provided
        ValueError : If at_2 is equal to either at_1 or at_3
        """

        # Imports
        import numpy as np
        from .utils import safe_cast as scast
        from .utils.vector import vec_angle

        # The below errors are explicitly thrown since they are multiplied by
        #  three when they are used as an index and thus give non-intuitive
        #  errors in later code.
        # Complain if at_1 is invalid
        if at_1 < -self.num_atoms or at_1 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_1' (" + str(at_1) + ")"))

        # Complain if at_2 is invalid
        if at_2 < -self.num_atoms or at_2 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_2' (" + str(at_2) + ")"))

        # Complain if at_3 is invalid
        if at_3 < -self.num_atoms or at_3 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_3' (" + str(at_3) + ")"))

        # Should never be necessary (save for badly erroneous calling code),
        #  but coerce the at_x to their floor() values.  This is again
        #  needed since they are multiplied by three in the index expresssions
        #  below, and can cause funny behavior when truncated by the indexing
        at_1 = scast(np.floor(at_1), np.int_)
        at_2 = scast(np.floor(at_2), np.int_)
        at_3 = scast(np.floor(at_3), np.int_)

        # Complain if at_2 is equal to either at_1 or at_3.  Must factor in
        #  the possibility of negative indexing via modulo arithmetic.
        if (at_2 % self.num_atoms) == (at_1 % self.num_atoms):
            raise(ValueError("'at_1' and 'at_2' must be different"))
        if (at_2 % self.num_atoms) == (at_3 % self.num_atoms):
            raise(ValueError("'at_2' and 'at_3' must be different"))

        # Trivial return if at_1 and at_3 are the same
        if (at_1 % self.num_atoms) == (at_3 % self.num_atoms):
            # Angle is identically zero in this case
            return 0.0
        ## end if

        # Store the displacement vectors from at_2 to at_1 and to at_3
        # The np.float64 type should be retained through the Displ_single call.
        vec_2_1 = self.Displ_single(g_num, at_2, at_1)
        vec_2_3 = self.Displ_single(g_num, at_2, at_3)

        # Compute and return the calculated angle, in degrees
        # v1 {dot} v2 == |v1||v2| * cos(theta)
        angle = vec_angle(vec_2_1, vec_2_3)
        return angle

    ## end def Angle_single


    def Angle_iter(self, g_nums, ats_1, ats_2, ats_3, invalid_error=False):
        """ Iterator over selected atomic angles.

        Returns the atomic angles between three sets of atoms ats_1, ats_2
            and ats_3 from geometries g_nums in degrees, with ats_2 as the
            central atoms.

        The various index pairs in ats_1 and ats_3 can be the same (yielding
            trivial zero angles), but each ats_2 must be different from both
            of the corresponding ats_1 and ats_3 values.
            Alternatively, exactly one parameter can be None and all other
            parameters single indices, in which case the full valid range of
            the `None` parameter is used.

        Parameters
        ----------
        g_nums : int or iterable int
            Index of the desired geometry (base 0)
        ats_1  : int or iterable int
            Index of the first atom (base 0)
        ats_2  : int or iterable int
            Index of the second atom (base 0)
        ats_3  : int or iterable int
            Index of the third atom (base 0)
        invalid_error  : bool, default False
            If False, 'None' values are returned for results corresponding to
            invalid indices. If True, exceptions are raised like normal.

        Generates
        ---------
        angle : np.float_
            Atomic angle in degrees between atoms at_1-at_2-at_3, from
            geometry g_num

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num, or at_n is provided
        ValueError : If any ats_2 is equal to either the corresponding ats_1
            or ats_3
        ValueError :  (via .utils.pack_tups) If all iterable objects are
            not the same length
        """
        # Suitability of ats_n indices will be checked within the
        #  self.Angle_single() calls and thus no check is needed here.

        # Import the tuple-generating function
        from .utils import pack_tups

        # Print the function inputs if debug mode is on
        if _DEBUG:   # pragma: no cover
            print("g_nums = " + str(g_nums))
            print("ats_1 = " + str(ats_1))
            print("ats_2 = " + str(ats_2))
            print("ats_3 = " + str(ats_3))
        ## end if

        # Perform the None substitution
        arglist = self._None_subst(g_nums, ats_1, ats_2, ats_3)

        # Expand/pack the tuples from the inputs
        tups = pack_tups(*arglist)

        # Dump the results if debug mode is on
        if _DEBUG:  # pragma: no cover
            print(tups)
        ## end if

        # Construct the generator using the packed tuples.
        for tup in tups:
            if _DEBUG: # pragma: no cover
                print(tup)
            ## end if

            yield self._iter_return(tup, self.Angle_single, invalid_error)
        ## next tup

    ## end def Angle_iter


    def Dihed_single(self, g_num, at_1, at_2, at_3, at_4):
        """ Retrieve a dihedral/out-of-plane angle from the OPAN_XYZ instance.

        Returns the out-of-plane angle among four atoms at_1, at_2, at_3
            and at_4 from geometry g_num, in degrees.  The reference plane
            is spanned by at_1, at_2 and at_3. The out-of-plane angle is
            defined such that a positive angle represents a counter-clockwise
            rotation of the projected at_3-to-at_4 vector with respect to the
            reference plane when looking from at_3 toward at_2.  Zero rotation
            corresponds to occlusion of at_1 and at_4; that is, the case when
            the respective normalized projections of at_1 --> at_2 and
            at_3 --> at_4 onto the reference plane are ANTI-PARALLEL.

        All four atom indices must be distinct. Both of the atom trios 1-2-3
            and 2-3-4 must be sufficiently nonlinear, as diagnosed by a bend
            angle different from 0 or 180 degrees by at least
            PRM.Non_Parallel_Tol

        Parameters
        ----------
        g_num   : int
            Index of the desired geometry (base 0)
        at_1    : int
            Index of the first atom (base 0)
        at_2    : int
            Index of the second atom (base 0)
        at_3    : int
            Index of the third atom (base 0)
        at_4    : int
            Index of the fourth atom (base 0)

        Returns
        -------
        dihed : np.float_
            Out-of-plane/dihedral angle in degrees for the indicated atoms,
            drawn from geometry g_num

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num, or at_n is provided

        ValueError : If any indices at_n are equal

        XYZError   : (typecode dihed) If either of the atom trios (1-2-3 or
            2-3-4) is too close to linearity
        """
        # library imports
        import numpy as np
        from scipy import linalg as spla
        from .utils.vector import ortho_basis, rej, vec_angle
        from .utils import safe_cast as scast
        from .error import XYZError
        from .const import PRM

        # Should never be necessary (save for badly erroneous calling code),
        #  but coerce the at_x to their floor() values.  This is again
        #  needed since they are multiplied by three in the index expresssions
        #  below, and can cause funny behavior when truncated by the indexing
        at_1 = scast(np.floor(at_1), np.int_)
        at_2 = scast(np.floor(at_2), np.int_)
        at_3 = scast(np.floor(at_3), np.int_)
        at_4 = scast(np.floor(at_4), np.int_)

        # Proofread the atom numbers. Performed by double-iterative scan of
        #  the atom numbers, converting the index equality test results to
        #  ints and summing the results.  Since each ats_n is not compared to
        #  itself, a sum of zero should diagnose the required mutually
        #  nonidentical indices.
        #
        # Pile the atom indices into a vector
        ats = [at_1, at_2, at_3, at_4]

        # Scan over the vector of indices pairwise without repetition, and
        #  without examining for at_i == at_i (which is trivially and always
        #  True).  Store the outcomes as integers (True == 1; False == 0)
        ats_test = [int(ats[x] == ats[y]) for x in range(4) \
                                        for y in range(x+1,4)]

        # For a proper set of indices, the sum over ats_test will be zero.
        if sum(ats_test) > 0:
            # Improper set of indices; at least one pair is duplicated.
            #  Collate the duplicative pairings and raise ValueError.
            #  np.triu_indices generates index pairs in the same sequence as
            #  the above double iteration over ats, but as a list of two
            #  np.arrays.  column_stack puts them together as column vectors,
            #  allowing the conditional iteration over x to select only those
            #  index pairs that correspond to duplicated indices.  The
            #  resulting filtered pairs are converted to tuples for concise
            #  formatting in the output.
            ats_pairs = [tuple(np.column_stack(np.triu_indices(4,1))[x])
                                        for x in range(6) if ats_test[x] == 1]
            raise(ValueError("Duplicate atom indices: " + str(ats_pairs)))
        ## end if

        # Check to ensure non-collinearity of the 1-2-3 and 2-3-4 atom trios
        for idx in range(2):
            # Store the relevant angle
            ang = self.Angle_single(g_num, [at_2, at_3][idx],
                                         [at_1, at_2][idx],
                                         [at_3, at_4][idx])

            # Check for whether angle is too close to zero or 180 degrees
            if np.min([ang, 180.0 - ang]) < PRM.Non_Parallel_Tol:
                # Too close; raise error
                raise(XYZError(XYZError.dihed,
                        "Angle " +
                            str([(at_2, at_1, at_3), (at_3, at_2, at_4)][idx])
                            + " is insufficiently nonlinear",
                        "XYZ file: " + self.XYZ_path))
            ## end if
        ## next idx

        # Store normalized atomic displacement vector at_2 --> at_3 as that
        #  defining the projection plane
        plane_norm = self.Displ_single(g_num, at_2, at_3)
        plane_norm /= spla.norm(plane_norm)

        # Retrieve the orthonormal basis in the projection plane, with the
        #  first vector being the normalized projection of the at_1 --> at_2
        #  displacement onto that plane
        on1, on2 = ortho_basis(plane_norm, \
                            self.Displ_single(g_num, at_1, at_2))

        # Project the at_3 --> at_4 displacement onto the plane
        #
        # Retrieve the "back-side" displacement vector
        back_vec = self.Displ_single(g_num, at_3, at_4)

        # Project onto the plane by subtracting out the plane_norm projection
        #  and re-normalize
        back_vec = rej(back_vec, plane_norm)
        back_vec /= spla.norm(back_vec)

        # Calculate the absolute value of the departure of the dihedral/
        #  out-of-plane angle from 180 degrees as derived from the dot-product
        #  of on1 and back_vec. Both should be normalized at this point, so
        #  the calculation is straightforward
        dihed = vec_angle(back_vec, on1)

        # Given the handedness of the spanning vectors provided by ortho_basis,
        #  the sign of the dihed departure is that of the dot product
        #  of back_vec and on2.
        dihed *= np.sign(np.dot(back_vec, on2))

        # Conversion to the stated typical definition of a dihedral now
        #  requires addition of 180 degrees.
        dihed += 180.0

        # Should be set to return the value
        return dihed

    ## end Dihed_single


    def Dihed_iter(self, g_nums, ats_1, ats_2, ats_3, ats_4, \
                                                    invalid_error=False):
        """ Iterator over selected dihedral angles.

        Returns the out-of-plane angle among each group of four atoms ats_1,
            ats_2, ats_3 and ats_4 from the corresponding geometries g_nums,
            in degrees.  The reference planes are spanned by the ats_1, ats_2
            and ats_3. The out-of-plane angles are defined such that a positive
            angle represents a counter-clockwise rotation of the projected
            at_3 --> at_4 vector with respect to the reference plane when
            looking from at_3 toward at_2.  Zero rotation corresponds to
            occlusion of at_1 and at_4; that is, the case when the respective
            normalized projections of at_1 --> at_2 and at_3 --> at_4 onto
            the reference plane are ANTI-PARALLEL.

        All four atom indices must be distinct in each corresponding group.
            Both of the atom trios 1-2-3 and 2-3-4 must be sufficiently
            nonlinear, as diagnosed by a bend angle different from 0 or 180
            degrees by at least PRM.Non_Parallel_Tol.

        Alternatively, exactly one parameter can be None and all other
            parameters single indices, in which case the full valid range of
            the `None` parameter is used.


        Parameters
        ----------
        g_nums   : int or iterable int
            Indices of the desired geometry (base 0)
        ats_1    : int or iterable int
            Indices of the first atoms (base 0)
        ats_2    : int or iterable int
            Indices of the second atoms (base 0)
        ats_3    : int or iterable int
            Indices of the third atoms (base 0)
        ats_4    : int or iterable int
            Indices of the fourth atoms (base 0)
        invalid_error  : bool, default False
            If False, 'None' values are returned for results corresponding to
            invalid indices. If True, exceptions are raised per normal.

        Returns
        -------
        dihed : np.float64 generator
            Out-of-plane/dihedral angles in degrees for the indicated atoms,
            drawn from g_nums

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_nums, or ats_n is provided

        ValueError : If any indices ats_n are equal within a group

        XYZError   : (typecode dihed) If either of the atom trios (1-2-3 or
            2-3-4) is too close to linearity for any group
        """
        # Suitability of ats_n indices will be checked within the
        #  self.Dihed_single() calls and thus no check is needed here.

        # Import the tuple-generating function
        from .utils import pack_tups

        # Print the function inputs if debug mode is on
        if _DEBUG:   # pragma: no cover
            print("g_nums = " + str(g_nums))
            print("ats_1 = " + str(ats_1))
            print("ats_2 = " + str(ats_2))
            print("ats_3 = " + str(ats_3))
            print("ats_4 = " + str(ats_4))
        ## end if

        # Perform the None substitution
        arglist = self._None_subst(g_nums, ats_1, ats_2, ats_3, ats_4)

        # Expand/pack the tuples from the inputs
        tups = pack_tups(*arglist)

        # Dump the results if debug mode is on
        if _DEBUG:   # pragma: no cover
            print(tups)
        ## end if

        # Construct the generator using the packed tuples.
        for tup in tups:
            yield self._iter_return(tup, self.Dihed_single, invalid_error)
        ## next tup

    ## end def Dihed_iter


    def Displ_single(self, g_num, at_1, at_2):
        """ Displacement vector between two atoms from an OPAN_XYZ instance.

        Returns the displacement vector pointing from at_1 toward at_2 from the
            indicated geometry.  If at_1 == at_2 the zero vector is returned.

        Displacement vector is returned in units of Bohrs.

        Parameters
        ----------
        g_num   : int
            Index of the desired geometry (base 0)
        at_1    : int
            Index of the first atom (base 0)
        at_2    : int
            Index of the second atom (base 0)

        Returns
        -------
        displ : length-3 np.array of np.float_
            Displacement vector from at_1 to at_2

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num, or at_n is provided

        """

        # Library imports
        import numpy as np
        from .utils import safe_cast as scast

        # The below errors are explicitly thrown since they are multiplied by
        #  three when they are used as an index and thus give non-intuitive
        #  errors.
        # Complain if at_1 is invalid
        if at_1 < -self.num_atoms or at_1 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_1' (" + str(at_1) + ")"))

        # Complain if at_2 is invalid
        if at_2 < -self.num_atoms or at_2 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_2' (" + str(at_2) + ")"))

        # Should never be necessary (save for badly erroneous calling code),
        #  but coerce at_1 and at_2 to their floor() values.  This is again
        #  needed since they are multiplied by three in the index expresssions
        #  below, and can cause funny behavior when truncated by the indexing
        at_1 = scast(np.floor(at_1), np.int_)
        at_2 = scast(np.floor(at_2), np.int_)

        # If the atom indices are the same, return trivial zero vector
        if (at_1 % self.num_atoms) == (at_2 % self.num_atoms):
            return np.array([0.0, 0.0, 0.0])
        ## end if

        # Retrieve the geometry; np.float_ type should be retained
        g = self.Geom_single(g_num)

        # Calculate the displacement vector and return
        displ = np.array([ g[i + 3*at_2] - g[i + 3*at_1] for i in range(3) ])

        # Return the displacement vector
        return displ

    ## end def Displ_single


    def Displ_iter(self, g_nums, ats_1, ats_2, invalid_error=False):
        """ Iterator over indicated displacement vectors.

        Returns the respective displacement vectors pointing from ats_1 toward
            ats_2 from the indicated geometries.

        Raised errors are those of Displ_single. Displacements are in Bohrs.

        Any of ats_1, ats_2 and g_nums can be either a single index or an
            iterable. Alternatively, exactly one parameter can be None and
            all other parameters single indices, in which case the full
            valid range of the `None` parameter is used.

        Parameters
        ----------
        g_nums : int or iterable int
            Index/indices of the desired geometry/geometries (base 0)
        ats_1 : int or iterable int
            Index/indices of the first atom(s) (base 0)
        ats_2 : int or iterable int
            Index/indices of the second atom(s) (base 0)
        invalid_error  : bool, default False
            If False, 'None' values are returned for results corresponding to
            invalid indices. If True, exceptions are raised per normal.

        Returns
        -------
        displ : np.float64 (generator)
            Displacement vector in Bohrs between each atom pair of ats_1 and
            ats_2 from the corresponding geometries of g_nums.

        Raises
        ------
        ValueError :  (via orca_utils.pack_tups) If all iterable objects are
            not the same length

        """

        # Import the tuple-generating function
        from .utils import pack_tups

        # Print the function inputs if debug mode is on
        if _DEBUG:  # pragma: no cover
            print("g_nums = " + str(g_nums))
            print("ats_1 = " + str(ats_1))
            print("ats_2 = " + str(ats_2))
        ## end if

        # Perform the None substitution
        arglist = self._None_subst(g_nums, ats_1, ats_2)

        # Expand/pack the tuples from the inputs
        tups = pack_tups(*arglist)

        # Dump the results if debug mode is on
        if _DEBUG:  # pragma: no cover
            print(tups)
        ## end if

        # Construct the generator using the packed tuples.
        for tup in tups:
            yield self._iter_return(tup, self.Displ_single, invalid_error)
        ## next tup

    ## end def Displ_iter


    def _None_subst(self, *args):
        """ Helper function to insert full ranges for 'None' for X_iter methods.

        Custom method, specifically tailored, taking in the arguments from
        an X_iter method and performing the replacement of 'None' after
        error-checking the arguments for a max of one 'None' value, and ensuring
        that if a 'None' is present, no other non-str iterables are present.

        Parameters
        ----------
        args : 3-5 arguments of int or iterable-int type, or none
            First argument is always the indices for the geometries; all
            following are for the atoms in sequence as required for the
            particular X_iter method

        Returns
        -------
        arglist     : 3-5 arguments, matching input params
            Argument list, with 'None' substituted if validly present

        Raises
        ------
        ValueError  : If more than one 'None' argument is present
        ValueError  : If an arg is non-str iterable when one 'None' is present
        """

        # Imports
        import numpy as np

        # Initialize argument list return value, and as None not found
        arglist = [a for a in args]
        none_found = False

        # Check for None values
        none_vals = map(lambda e: isinstance(e, type(None)), arglist)

        # Error if more than one None; handle if exactly one; pass through if
        #  none.
        if np.count_nonzero(none_vals) > 1:
            raise(ValueError("Multiple 'None' values [indices " + \
                    str(tuple(np.nonzero(none_vals)[0])) + "] not supported"))
        elif np.count_nonzero(none_vals) == 1:
            # Must be no iterables that are not strings. Thus, an element-wise
            #  test for iterability and an element-wise test for stringiness
            #  must give matching arrays
            if not all(np.equal(map(np.iterable, arglist), \
                                map(lambda e: isinstance(e, str), arglist))):
                raise(ValueError("'None' as parameter invalid with " + \
                                                        "non-str iterables"))
            ## end if

            # Parameters okay; replace the None with the appropriate range()
            none_found = True
            none_loc = np.nonzero(none_vals)[0][0]
            arglist[none_loc] = \
                    range(self.num_geoms if none_loc == 0 else self.num_atoms)
        ## end if

        # Return the arguments list and the none-found value
        return arglist

    ## end def _None_subst


    @staticmethod
    def _iter_return(tup, fxn, invalid_error):
        """ Wrapper for error/None output handling of X_iter methods.

        Attempts to pass 'tup' as arguments to 'fxn'.  If the call is
        successful, returns the value produced. If IndexError or ValueError
        is raised, indicating an invalid index value, re-raise if invalid_error
        is True or return 'None' if False.  Other Exceptions are left uncaught.

        Parameters
        ----------
        tup     : tuple
            Input arguments to unpack as arguments to 'fxn'
        fxn     : callable
            Function/method to call to calculate the return value
        invalid_error   : bool
            Flag for whether to return None on IndexError/ValueError, or to
            re-raise

        Returns
        -------
        val     : np.float_ or None
            Calculated value from fxn(*tup) call, or 'None' value indicating
            IndexError / ValueError

        """

        try:
            val = fxn(*tup)
        except (IndexError, ValueError):
            if invalid_error:
                # Raise the exception if invalid_error indicates
                raise
            else:
                # Otherwise, just return a 'None' value
                return None
            ## end if
        else:
            # Good value; just generate it
            return val
        ## end try

    ## end def _iter_return

## end class OPAN_XYZ


if __name__ == '__main__':  # pragma: no cover
    print("Module not executable")
