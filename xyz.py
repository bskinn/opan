#-------------------------------------------------------------------------------
# Name:        xyz
# Purpose:     Encapsulation of parsing/handling of data from OpenBabel-type
#                molecule geometry files.
#
# Author:      Brian Skinn
#                bskinn@alum.mit.edu
#
# Created:     13 Aug 2014
# Copyright:   (c) Brian Skinn 2015
# License:     The MIT License; see "license.txt" for full license terms
#                   and contributor agreement.
#
#       This file is part of opan (OpenAnharmonic), a system for automated
#       computation of anharmonic properties of molecular systems via wrapper
#       calls to computational/quantum chemical software packages.
#
#       http://www.github.com/bskinn/opan
#
#-------------------------------------------------------------------------------

# Imports


# Debug constant
_DEBUG = False


class OPAN_XYZ(object):
    """ Container for OpenBabel XYZ data.

    Contains all geometries present in the OpenBabel file at the path passed
    to __init__.

    'N' and 'G' in the below documentation refer to the number of atoms per
    geometry and the number of geometries present in the file, respectively.
    Note that *ALL* geometries present *MUST* contain the same number of atoms,
    and must all *FALL IN THE SAME SEQUENCE* of elements. The class and
    functions won't complain if positions of like atoms are swapped, but this
    will almost certainly cause all sorts of trouble to downstream code.

    Initializer can be called in one of two forms:

        OPAN_XYZ(path='path/to/file')
        OPAN_XYZ(atom_syms={array of atoms}, coords={array of coordinates})

    In both forms, the optional keyword argument 'bohrs' can be specified, to
    indicate the units of the coordinates as Bohrs (True) or Angstroms (False).
    Angstrom and Bohr units are the default for the first and second forms,
    respectively. The units of all coordinates stored in the instance are
    *Bohrs*.

    In ORCA, XYZ files contain the highest precision geometry
    information of any output save perhaps the textual output generated by
    the program, and are stored in Angstrom units.

    Instantiation
    -------------
    (see above)

    Class Variables
    ---------------
    p_coords    : re.compile() pattern
        RegEx for single, full blocks of coordinates
    p_geom      : re.compile() pattern
        RegEx for lines of coordinates within a geometry block

    Instance Variables
    ------------------
    XYZ_path    : str
        Full path to imported OpenBabel file
    atom_syms   : N x 1 str np.array
        Atomic symbols for the atoms
    descs       : G x 1 x 1 np.array of str
        Text descriptions for each geometry included in the file
    geoms       : G x N x 1 np.array of np.float_
        Molecular geometry/geometries, stored as an array of N x 1 vectors
    in_str      : str
        Complete contents of input file
    initialized : bool
        Flag for whether instance has already been constructed
    num_atoms   : int
        Number of atoms per geometry, N
    num_geoms   : int
        Number of geometries found, G

    Methods
    -------
    Geom_single(g_num)
        Return the N x 1 np.array of geometry with index 'g_num'
    Displ_single(g_num, at_1, at_2)
        Return the vector displacement from at_1 toward at_2 as a 3 x 1
        np.matrix, in Bohr units
    Dist_single(g_num, at_1, at_2)
        Return the Euclidean distance between atoms with indices 'at_1' and
        'at_2' for geometry 'g_num' in Bohr units
    Angle_single(g_num, at_1, at_2, at_3)
        Return the bond angle at_1 --> at_2 --> at_3 for geometry 'g_num' in
        degrees. at_2 must be distinct from both at_1 and at_3.
    Dihed_single(g_num, at_1, at_2, at_3, at_4)
        Return the dihedral angle at_1 --> at_2 --> at_3 --> at_4 in degrees
        for geometry 'g_num'. See the function docstring for more details and
        restrictions on atom indices and structural parameters.

    Generators
    ----------
    == In all of the below, each parameter can either be an iterable of     ==
    == indices or a single index. If more than one parameter is an iterable ==
    == then they all must have the same length 'N'.  The generator will     ==
    == iterate over each set of indices from 1 to N, taking each iterable   ==
    == value once, and using any single-index parameters in each case.      ==
    == #DOC: Update with 'None' param option once implemented.              ==
    Geom_iter(g_nums)
        Iterate over the geometries specified by the indices 'g_nums'
    Displ_iter(g_nums, ats_1, ats_2)
        Iterate over a series of displacements.
    Dist_iter(g_nums, ats_1, ats_2)
        Iterate over a series of Euclidean distances
    Angle_iter(g_nums, ats_1, ats_2, ats_3)
        Iterate over a series of bond angles
    Dihed_iter(g_nums, ats_1, ats_2, ats_3, ats_4)
        Iterate over a series of dihedral angles

    """

    # Imports
    import re as _re

    # Class constants
    LOAD_DATA_FLAG = "DATA"

    # Define the RegEx to pull entire geometry blocks
    # re.M is required in order for the "^" at the start of the pattern
    #  to match more than just the first geometry block in a file
    # The "[^\\n\\w]" pattern is a weak equivalent of \\s, made necessary
    #  since \\s *includes* \\n.
    # Perhaps "[ \\t]" will suffice...
    p_geom = _re.compile("""
    ^(?P<num>\\d+)      # Integer number of atoms
    [ \\t]*\\n          # Whitespace scrub to end of line
    (?P<desc>[^\\n]+)   # Geometry description
    \\n                 # Newline to end geometry description
    (?P<coord>          # Open group for entire set of atom coords
        (                   # Open group for one coord line
            [ \\t]*?            # Any whitespace before element
            ([a-z]+|\\d+)       # Element name or atomic #
            (                   # Open group for coord value
                [ \\t]+?            # Any whitespace before coord value
                [0-9.-]+            # Decimal coordinate value
            ){3}                # Three coordinates to retrieve
            [ \\t]*\\n          # Any whitespace to end of line
        )+                  # Close one coord line group; should be >= 1
    )                   # Close group for entire set of atom coords
    """, _re.I | _re.X | _re.M)

    # Define the RegEx to pull individual lines from the coordinate block
    #  retrieved by the p_geom RegEx.
    # As w/p_geom, re.M is required for "^" to match the start of each line of
    #  the coords block.
    p_coords = _re.compile("""
    ^[ \\t]*?               # Any whitespace before element id
    (?P<el>([a-z]+|\\d+))   # Element ID, symbol or atomic number
    [ \\t]+?                # Whitespace before first coordinate
    (?P<c1>[0-9.-]+)        # First coordinate
    [ \\t]+?                # Whitespace before second coordinate
    (?P<c2>[0-9.-]+)        # Second coordinate
    [ \\t]+?                # Whitespace before third coordinate
    (?P<c3>[0-9.-]+)        # Third coordinate
    """, _re.I | _re.X | _re.M)


    def __init__(self, **kwargs):
        """ Initialize XYZ data from file or existing geometry.

        Initializer can be called in one of two forms:

        OPAN_XYZ(path='path/to/file')
        OPAN_XYZ(atom_syms={array of atoms}, coords={array of coordinates})

        In both forms, the optional keyword argument 'bohrs' can be specified,
        to indicate the units of the coordinates as Bohrs (True) or
        Angstroms (False). Angstrom and Bohr units are the default for the
        first and second forms, respectively. The units of all coordinates
        stored in the instance are *Bohrs*, regardless of this setting.
        """

        # Two situations. One should have 'path' and, optionally, 'bohrs'
        #  specified (default here is Angstroms). The other needs an N x 1
        #  'atom_syms' vector and a 3N x 1 'coords' vector.
        if 'path' in kwargs:
            # All set for load from file. 'bohrs' defaults False here
            self._load_file(kwargs['path'], \
                    bohrs=(kwargs['bohrs'] if 'bohrs' in kwargs else False))
        else:
            # Look for the from-coordinates objects
            if all([(k in kwargs) for k in ('atom_syms', 'coords')]):
                # Found. Call the by-data initializer. 'bohrs' defaults to
                #  TRUE here (presume main call is from repo)
                self._load_data(kwargs['atom_syms'], \
                        kwargs['coords'], \
                        bohrs=(kwargs['bohrs'] if 'bohrs' in kwargs else True))
            else:
                # NOT found -- error!
                raise(NameError("Insufficient named parameters found"))
            ## end if
        ## end if

    ## end def __init__


    def _load_data(self, atom_syms, coords, bohrs=True):
        """ Internal function for making XYZ object from explicit geom data.

        Parameters
        ----------
        atom_syms   : flattens to array of N strings
            Element symbols for the XYZ. Must be valid elements as defined in
            .const.atomNum.keys()
        coords      : flattens to array of 3N float-castables
            Coordinates for the geometry (x1, y1, z1, x2, y2, ...)
        bohrs       : bool, default True
            Units of coordinates

        Raises
        ------
        XYZError    : If ORCA_XYZ object has already been initialized
        ValueError  : If atom_syms & coords dimensions are incompatible
        ValueError  : If types of atom_syms or coords are invalid
        """

        # Imports
        import numpy as np
        from .const import atomNum
        from .error import XYZError

        # Gripe if already initialized
        if 'initialized' in dir(self):
            raise(XYZError(XYZError.overwrite, \
                    "Cannot overwrite contents of existing OPAN_XYZ", ""))
        ## end if

        # Smash inputs to flat arrays
        work_atoms = np.array(atom_syms).flatten()
        work_coords = np.array(coords).flatten()

        # Check and store dimensions
        if not work_coords.shape[0] == 3 * work_atoms.shape[0]:
            raise(ValueError("len(coords) != 3 * len(atom_syms)"))
        ## end if

        # Proof the atoms list
        if not all([(work_atoms[i].upper() in atomNum) \
                                for i in range(work_atoms.shape[0])]):
            # Invalid atoms specified
            raise(ValueError("Invalid atoms specified: " + str( \
                    [(j, work_atoms[j]) for j in \
                        [i for i, valid in \
                            enumerate(map( \
                                        lambda k: k in atomNum, \
                                        work_atoms)) \
                            if not valid \
                        ] \
                    ] )))
        ## end if

        # Ensure the geometry is all numeric
        if not all(map(np.isreal, work_coords)):
            raise(ValueError("All coordinates must be real numeric"))
        ## end if

        # Store the number of atoms. Only one geometry. Standard string
        #  content for things only relevant to file load.
        self.num_atoms = work_atoms.shape[0]
        self.num_geoms = 1
        self.in_str = self.LOAD_DATA_FLAG
        self.descs = np.array([[self.LOAD_DATA_FLAG]])
        self.XYZ_path = self.LOAD_DATA_FLAG

        # Store the atoms by just expanding a dimension
        self.atom_syms = np.array(map(str.upper, \
                                list(work_atoms.flatten())))[:,np.newaxis]

        # Store the geometry by bracketing with new dimensions
        self.geoms = work_coords[np.newaxis, :, np.newaxis]

        self.initialized = True

    ## end def load_data


    def _load_file(self, XYZ_path, bohrs=False):
        """ Initialize OPAN_XYZ geometry object from OpenBabel file

        Import of an arbitrary number of multiple geometries from an OpenBabel
        file. All geometries must have the same number and type of atoms,
        and the ordering of atom types must be retained throughout.

        Parameters
        ----------
        XYZ_path : string
            Complete path to the .xyz / .trj file to be read
        bohrs    : bool, optional
            Flag for whether coordinates are interpreted as in Bohrs or
            Angstroms. Default is False = Angstroms.

        Raises
        ------
        XYZError : If indicated geometry file is malformed in some fashion
        IOError  : If the indicated file does not exist or cannot be read
        """

        # Imports
        import numpy as np
        from .const import CIC, PHYS, atomNum, atomSym
        from .error import XYZError
        from .utils import safe_cast as scast

        # Complain if already initialized
        if 'initialized' in dir(self):
            raise(XYZError(XYZError.overwrite, \
                    "Cannot overwrite contents of existing OPAN_XYZ", ""))
        ## end if

        # Open file, read contents, close stream
        # No particular exception handling; that will be the responsibility
        #  of the calling routine.
        # May want to add a check for text file format; but, really, a check
        #  for no-found-geometry-information will likely cover such a case.
        with open(XYZ_path,'rU') as in_fl:
            self.XYZ_path = XYZ_path
            self.in_str = in_fl.read()

        # Check to ensure at least one geom match; else raise some sort of
        #  error
        if not OPAN_XYZ.p_geom.search(self.in_str):
            raise(XYZError(XYZError.xyzfile,
                    "No valid geometry found",
                    "XYZ file: " + XYZ_path))
        ## end if

        # Store the number of atoms. XYZ files with multiple geometries will
        #  be required to have the same number of atoms in all geometries.
        #  This is fine for OpenAnharmonic, but may be highly undesirable
        #  in other applications.  Beware.
        # If the .match() call doesn't have a group attribute, catch the
        #  resulting AttributeError and throw an XYZError. Can't think of any
        #  other situation that would throw an AttributeError here, so probably
        #  I don't have to check for a subtype of AttributeError...
        # Can't think of a need for an else or a finally here
        try:
            self.num_atoms = scast(OPAN_XYZ.p_geom.match(self.in_str)
                                            .group("num"), np.int_)
        except AttributeError:
            raise(XYZError(XYZError.xyzfile,
                    "No geometry block found at start of file",
                    "XYZ file: " + XYZ_path))
        ## end try

        # Initialize the description vector and geometry array
        # CANNOT use matrix type for the geometry since it's 3D.
        # Retriever function for geometry should convert the given slice
        #  to a vector as an np.matrix, though.
        # Geometry is constructed as a 3N x 1 matrix (column vector) of
        #  coordinates, where atom 1's x/y/z coordinates are sequential,
        #  then atom 2's x/y/z coordinates are sequential, etc.
        # Multiple geometries in a single XYZ file are stacked in a third
        #  dimension, which for the default py array ordering is the *first*
        #  index: array3d[a,b,c] returns the element from the b-th row and
        #  c-th column of the a-th stacked matrix in array3d.
        self.descs = np.empty((0,1,1))
        self.geoms = np.empty((0, self.num_atoms * 3, 1), dtype=np.float64)

        # Initialize the atom symbols vector
        self.atom_syms = np.empty((0,1), dtype=str)

        # Define a counter for the number of geometries. Store as a persistent
        #  instance variable because it will be useful later.
        self.num_geoms = 0

        # Loop over the geometry blocks found in the input file
        for mch in OPAN_XYZ.p_geom.finditer(self.in_str):
            # Check that the number of atoms is consistent with the spec
            #  found in the first geometry block
            if not scast(mch.group("num"), np.int_) == self.num_atoms:
                raise(XYZError(XYZError.xyzfile,
                        "Non-constant number of atoms in multiple geometry",
                        "XYZ file: " + XYZ_path))
            ## end if

            # Store the description for the current geometry
            self.descs = np.concatenate((self.descs,[[[mch.group("desc")]]]),
                        axis=0)

            # Assemble the coordinates vector and assemble/check the element
            #  ID vector.
            # Reset the atom counter and the coordinates vector
            atom_count = 0
            coord_vec = np.empty((0,1),dtype=np.float64)
            for line_mch in OPAN_XYZ.p_coords.finditer(mch.group("coord")):
                # Check for whether element list has been fully populated
                if self.atom_syms.shape[0] < self.num_atoms:
                    # If not, continue populating it; have to check for
                    #  whether it's an atomic number or an element symbol
                    if str.isdigit(line_mch.group("el")):
                        # Atomic number
                        # Check for valid number
                        at_num = scast(line_mch.group("el"), np.int_)
                        if not (at_num >= CIC.Min_Atomic_Num and
                                    at_num <= CIC.Max_Atomic_Num):
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is an unsupported element",
                                     "XYZ file: " + XYZ_path))
                        ##end if

                        # Tag on the new symbol
                        self.atom_syms = np.concatenate(
                                (
                                    self.atom_syms,
                                    np.array([[atomSym[at_num]]])
                                 ), axis=0               )
                    else:
                        # Element symbol; store as all caps
                        # Check for valid element, first by catching if the
                        #  specified element string is even valid
                        try:
                            at_num = atomNum[str.upper(line_mch.group("el"))]
                        except KeyError:
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is an unrecognized element",
                                     "XYZ file: " + XYZ_path))
                        ## end try

                        # Tag on the new symbol
                        self.atom_syms = np.concatenate((self.atom_syms,
                                    np.array([[
                                        str.upper(line_mch.group("el"))
                                                ]])),
                                axis=0)
                    ## end if
                else: # List is fully populated
                    # If so, confirm that the element specified at the current
                    #  line matches that of the first geometry of the file
                    # Have to check whether it's an atomic number or symbol.
                    if str.isdigit(line_mch.group("el")):
                        # Atomic number; don't need safe cast; must trap for
                        #  a bad atomic number
                        at_num = scast(line_mch.group("el"), np.int_)
                        if not (at_num >= CIC.Min_Atomic_Num and
                                    at_num <= CIC.Max_Atomic_Num):
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is an unsupported element",
                                     "XYZ file: " + XYZ_path))
                        ## end if
                        if not atomSym[int(line_mch.group("el"))] == \
                                self.atom_syms[atom_count,0]:
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is inconsistent with geometry #0",
                                     "XYZ file: " + XYZ_path))
                        ## end if

                    else:
                        # Element symbol
                        # Check for valid element, first by catching if the
                        #  specified element string is even valid
                        try:
                            at_num = atomNum[str.upper(line_mch.group("el"))]
                        except KeyError:
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is an unrecognized element",
                                     "XYZ file: " + XYZ_path))
                        ## end try
                        # Confirm symbol matches the initial geometry
                        if not str.upper(line_mch.group("el")) == \
                                self.atom_syms[atom_count,0]:
                            raise(XYZError(XYZError.xyzfile,
                                    "Geometry #" + str(self.num_geoms) +
                                    ", atom #" + str(atom_count) +
                                    " is inconsistent with geometry #0",
                                    "XYZ file: " + XYZ_path))
                        ## end if
                    ## end if
                ## end if

                # Append the three coordinates of the current atom to the
                #  temp coordinates vector, converting to Bohrs if indicated.
                # Working in Bohrs is desired because they are atomic units
                #  and thus are part of the internal unit definition of the
                #  Hartree.
                for c_str in range(1,4):
                    coord_vec = np.concatenate(
                            (
                            coord_vec,
                            np.array([[
                        scast(line_mch.group("c" + str(c_str)), np.float_) /
                        (1.0 if bohrs else PHYS.Ang_per_Bohr)
                                       ]])
                            ), axis=0         )
                ## next c_str

                # Increment the atom_count for the atom number
                atom_count += 1

            ## next line_mch

            # Confirm that number of imported coordinates matches the
            #  number expected from self.num_atoms
            if not coord_vec.shape[0] == 3*self.num_atoms:
                raise(XYZError(XYZError.xyzfile,
                        "Geometry #" + str(self.num_geoms)+
                        " atom count is inconsistent",
                        "XYZ file: " + XYZ_path))
            ## end if

            # Assemble the coordinates vector into the actual coordinates
            #  stack for the XYZ
            self.geoms = np.concatenate(
                    (   self.geoms,
                        np.expand_dims(coord_vec,axis=0)
                     ), axis=0          )

            # Increment the count of the number of geometries. Once the
            #  'mch' iteration is completed, this will accurately reflect
            #  the number of geometries read from the file.
            self.num_geoms += 1

        ## next mch

        # Set the internal initialization flag
        self.initialized = True

    ## end def load_file


    def Geom_single(self, g_num):
        """ Retrieve a single geometry from the OPAN_XYZ instance.

        The atom coordinates are returned as a numpy.matrix column vector,
            with each atom's x/y/z coordinates returned together:
            [[A1x],[A1y],[A1z],[A2x],[A2y],[A2z],...]

        Parameters
        ----------
        g_num : int
            Index of the desired geometry (base 0)

        Returns
        -------
        geom : (3*num_atoms,1) np.matrix
            3N x 1 column vector of the atomic coordinates for the geometry
            indicated by 'g_num'

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num is provided
        """

        # Imports
        import numpy as np

        # Just return the appropriate geometry vector
        geom = np.matrix(
                self.geoms[g_num,:,:]
                         )
        return geom

    #TODO: Augment the _iter methods to accept a max of one 'None' in the
    #  list of parameters, which translates to ALL relevant geoms/atoms; atoms
    #  list will have to have invalid atoms excluded.
    def Geom_iter(self, g_nums):
        """Iterator over selected geometries from the OPAN_XYZ instance.

        The indices of the geometries to be returned are indicated by a
            list of integers passed as g_nums.

        Each set of atom coordinates is returned as a numpy.matrix column
            vector, with each atom's x/y/z coordinates returned together:
            [[A1x],[A1y],[A1z],[A2x],[A2y],[A2z],...]

        Parameters
        ----------
        g_nums : (N) list-like, int
            Indices of the desired geometries for iteration (base 0)

        Returns
        -------
        geom : (3*num_atoms,1) np.matrix (generator)
            3N x 1 column vector of the atomic coordinates for each geometry
            indicated by 'g_nums'

        Raises
        ------
        IndexError : If an invalid (out-of-range) entry of g_nums is provided
        ValueError :  (via .utils.pack_tups) If all iterable objects are
            not the same length
        """
        # Using the custom coded pack_tups to not have to care whether the
        #  input is iterable
        from .utils import pack_tups

        vals = pack_tups(g_nums)
        for val in vals:
            yield self.Geom_single(val)


    def Dist_single(self, g_num, at_1, at_2):
        """ Retrieve an interatomic distance from the OPAN_XYZ instance.

        Returns the interatomic distance between the two atoms at_1 and at_2
            from geometry g_num in Bohrs.

        Parameters
        ----------
        g_num : int
            Index of the desired geometry (base 0)
        at_1 : int
            Index of the first atom (base 0)
        at_2 : int
            Index of the second atom (base 0)

        Returns
        -------
        dist : np.float64
            Interatomic distance in Bohrs between atoms at_1 and at_2 from
            geometry g_num

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num, at_1 or at_2
            is provided
        """
        # Import used math library function(s)
        import numpy as np
        from numpy import floor
        from scipy.linalg import norm
        from .utils import safe_cast as scast

        # The below errors are explicitly thrown since they are multiplied by
        #  three when they are used as an index and thus give non-intuitive
        #  errors
        # Complain if at_1 is invalid
        if at_1 < -self.num_atoms or at_1 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_1' (" + str(at_1) + ")"))

        # Complain if at_2 is invalid
        if at_2 < -self.num_atoms or at_2 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_2' (" + str(at_2) + ")"))

        # Should never be necessary (save for badly erroneous calling code),
        #  but coerce at_1 and at_2 to their floor() values.  This is again
        #  needed since they are multiplied by three in the index expresssions
        #  below, and can cause funny behavior when truncated by the indexing
        at_1 = int(floor(at_1))
        at_2 = int(floor(at_2))

        # Calculate the interatomic distance and return
        dist = scast(norm(self.Displ_single(g_num, at_1, at_2)), np.float_)
        return dist


    def Dist_iter(self, g_nums, ats_1, ats_2):
        """ Iterator over selected interatomic distances.

        Returns the interatomic distances between the two atom sets ats_1 and
            ats_2 from geometries g_nums in Bohrs.

        Any of ats_1, ats_2 and g_nums can be either a single index or an
            iterable.

        Parameters
        ----------
        g_nums : int or iterable int
            Index/indices of the desired geometry/geometries (base 0)
        ats_1 : int or iterable int
            Index/indices of the first atom(s) (base 0)
        ats_2 : int or iterable int
            Index/indices of the second atom(s) (base 0)

        Returns
        -------
        dist : np.float64 (generator)
            Interatomic distance in Bohrs between each atom pair of ats_1 and
            ats_2 from the corresponding geometries of g_nums.

        Raises
        ------
        ValueError :  (via .utils.pack_tups) If all iterable objects are
            not the same length

        """

        # Import the tuple-generating function
        from .utils import pack_tups

        # Print the function inputs if debug mode is on
        if _DEBUG:  # pragma: no cover
            print("g_nums = " + str(g_nums))
            print("ats_1 = " + str(ats_1))
            print("ats_2 = " + str(ats_2))
        ## end if

        # Expand/pack the tuples from the inputs
        tups = pack_tups(g_nums, ats_1, ats_2)

        # Dump the results if debug mode is on
        if _DEBUG:  # pragma: no cover
            print(tups)
        ## end if

        # Construct the generator using the packed tuples.
        for tup in tups:
            yield self.Dist_single(*tup)
        ## next tup


    def Angle_single(self, g_num, at_1, at_2, at_3):
        """ Retrieve an atomic angle from the OPAN_XYZ instance.

        Returns the angle between three atoms at_1, at_2 and at_3
            from geometry g_num in degrees, with at_2 the central atom.

        The indices at_1 and at_3 can be the same (yielding a trivial zero
            angle), but at_2 must be different from both at_1 and at_3.

        Parameters
        ----------
        g_num : int
            Index of the desired geometry (base 0)
        at_1 : int
            Index of the first atom (base 0)
        at_2 : int
            Index of the second atom (base 0)
        at_3 : int
            Index of the third atom (base 0)

        Returns
        -------
        angle : np.float64
            Atomic angle in degrees between atoms at_1-at_2-at_3, from
            geometry g_num

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num, or at_n is provided
        ValueError : If at_2 is equal to either at_1 or at_3
        """
        # Import library function(s)
        import numpy as np
        from numpy import squeeze, arccos, floor
        from scipy.linalg import norm
        from .utils import safe_cast as scast

        # The below errors are explicitly thrown since they are multiplied by
        #  three when they are used as an index and thus give non-intuitive
        #  errors
        # Complain if at_1 is invalid
        if at_1 < -self.num_atoms or at_1 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_1' (" + str(at_1) + ")"))

        # Complain if at_2 is invalid
        if at_2 < -self.num_atoms or at_2 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_2' (" + str(at_2) + ")"))

        # Complain if at_2 is invalid
        if at_3 < -self.num_atoms or at_3 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_3' (" + str(at_3) + ")"))

        # Should never be necessary (save for badly erroneous calling code),
        #  but coerce at_1 and at_2 to their floor() values.  This is again
        #  needed since they are multiplied by three in the index expresssions
        #  below, and can cause funny behavior when truncated by the indexing
        at_1 = int(floor(at_1))
        at_2 = int(floor(at_2))
        at_3 = int(floor(at_3))

        # Complain if at_2 is equal to either at_1 or at_3.  Must factor in
        #  the possibility of negative indexing via modulo arithmetic.
        if (at_2 % self.num_atoms) == (at_1 % self.num_atoms):
            raise(ValueError("'at_1' and 'at_2' must be different"))
        if (at_2 % self.num_atoms) == (at_3 % self.num_atoms):
            raise(ValueError("'at_2' and 'at_3' must be different"))

        # Store the displacement vectors from at_2 to at_1 and to at_3
        # The np.float64 type should be retained through the Displ_single call.
        vec_2_1 = squeeze(np.array(self.Displ_single(g_num, at_2, at_1)))
        vec_2_3 = squeeze(np.array(self.Displ_single(g_num, at_2, at_3)))

        # Compute and return the calculated angle, in degrees
        # v1 {dot} v2 == |v1||v2| * cos(theta)
        angle = np.degrees(arccos(
                    np.dot(vec_2_1,vec_2_3) / (norm(vec_2_1) * norm(vec_2_3))
                                ))
        return angle


    def Angle_iter(self, g_nums, ats_1, ats_2, ats_3):
        """ Iterator over selected atomic angles.

        Returns the atomic angles between three sets of atoms ats_1, ats_2
            and ats_3 from geometries g_nums in degrees, with ats_2 as the
            central atoms.

        The various index pairs in ats_1 and ats_3 can be the same (yielding
            trivial zero angles), but each ats_2 must be different from both
            of the corresponding ats_1 and ats_3 values.

        Parameters
        ----------
        g_nums : int or iterable int
            Index of the desired geometry (base 0)
        ats_1  : int or iterable int
            Index of the first atom (base 0)
        ats_2  : int or iterable int
            Index of the second atom (base 0)
        ats_3  : int or iterable int
            Index of the third atom (base 0)

        Returns
        -------
        angle : np.float64
            Atomic angle in degrees between atoms at_1-at_2-at_3, from
            geometry g_num

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num, or at_n is provided
        ValueError : If any ats_2 is equal to either the corresponding ats_1
            or ats_3
        ValueError :  (via .utils.pack_tups) If all iterable objects are
            not the same length
        """
        # Suitability of ats_n indices will be checked within the
        #  self.Angle_single() calls and thus no check is needed here.

        # Import the tuple-generating function
        from .utils import pack_tups

        # Print the function inputs if debug mode is on
        if _DEBUG:   # pragma: no cover
            print("g_nums = " + str(g_nums))
            print("ats_1 = " + str(ats_1))
            print("ats_2 = " + str(ats_2))
            print("ats_3 = " + str(ats_3))
        ## end if

        # Expand/pack the tuples from the inputs
        tups = pack_tups(g_nums, ats_1, ats_2, ats_3)

        # Dump the results if debug mode is on
        if _DEBUG:  # pragma: no cover
            print(tups)
        ## end if

        # Construct the generator using the packed tuples.
        for tup in tups:
            yield self.Angle_single(*tup)
        ## next tup


    def Dihed_single(self, g_num, at_1, at_2, at_3, at_4):
        """ Retrieve a dihedral/out-of-plane angle from the OPAN_XYZ instance.

        Returns the out-of-plane angle among four atoms at_1, at_2, at_3
            and at_4 from geometry g_num, in degrees.  The reference plane
            is spanned by at_1, at_2 and at_3. The out-of-plane angle is
            defined such that a positive angle represents a counter-clockwise
            rotation of the projected at_3-to-at_4 vector with respect to the
            reference plane when looking from at_3 toward at_2.  Zero rotation
            corresponds to occlusion of at_1 and at_4; that is, the case when
            the respective normalized projections of at_1 --> at_2 and
            at_3 --> at_4 onto the reference plane are ANTI-PARALLEL.

        All four atom indices must be distinct. Both of the atom trios 1-2-3
            and 2-3-4 must be sufficiently nonlinear, as diagnosed by a bend
            angle different from 0 or 180 degrees by at least
            PRM.Non_Parallel_Tol

        Parameters
        ----------
        g_num   : int
            Index of the desired geometry (base 0)
        at_1    : int
            Index of the first atom (base 0)
        at_2    : int
            Index of the second atom (base 0)
        at_3    : int
            Index of the third atom (base 0)
        at_4    : int
            Index of the fourth atom (base 0)

        Returns
        -------
        dihed : np.float_
            Out-of-plane/dihedral angle in degrees for the indicated atoms,
            drawn from geometry g_num

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num, or at_n is provided

        ValueError : If any indices at_n are equal

        XYZError   : (typecode dihed) If either of the atom trios (1-2-3 or
            2-3-4) is too close to linearity
        """
        # library imports
        import numpy as np
        from numpy import arccos, degrees, dot, sign, squeeze
        from scipy.linalg import norm
        from .utils.vector import ortho_basis
        from .error import XYZError
        from .const import PRM

        # Proofread the atom numbers. Performed by double-iterative scan of
        #  the atom numbers, converting the index equality test results to
        #  ints and summing the results.  Since each ats_n is not compared to
        #  itself, a sum of zero should diagnose the required mutually
        #  nonidentical indices.
        #
        # Pile the atom indices into a vector
        ats = [at_1, at_2, at_3, at_4]

        # Scan over the vector of indices pairwise without repetition, and
        #  without examining for at_i == at_i (which is trivially and always
        #  True).  Store the outcomes as integers (True == 1; False == 0)
        ats_test = [int(ats[x] == ats[y]) for x in range(4) \
                                        for y in range(x+1,4)]

        # For a proper set of indices, the sum over ats_test will be zero.
        if sum(ats_test) > 0:
            # Improper set of indices; at least one pair is duplicated.
            #  Collate the duplicative pairings and raise ValueError.
            #  np.triu_indices generates index pairs in the same sequence as
            #  the above double iteration over ats, but as a list of two
            #  np.arrays.  column_stack puts them together as column vectors,
            #  allowing the conditional iteration over x to select only those
            #  index pairs that correspond to duplicated indices.  The
            #  resulting filtered pairs are converted to tuples for concise
            #  formatting in the output.
            ats_pairs = [tuple(np.column_stack(np.triu_indices(4,1))[x])
                                        for x in range(6) if ats_test[x] == 1]
            raise(ValueError("Duplicate atom indices: " + str(ats_pairs)))
        ## end if

        # Check to ensure non-collinearity of the 1-2-3 and 2-3-4 atom trios
        for idx in range(2):
            # Store the relevant angle
            ang = self.Angle_single(g_num, [at_2, at_3][idx],
                                         [at_1, at_2][idx],
                                         [at_3, at_4][idx])

            # Check for whether angle is too close to zero or 180 degrees
            if np.min([ang, 180.0 - ang]) < PRM.Non_Parallel_Tol:
                # Too close; raise error
                raise(XYZError(XYZError.dihed,
                        "Angle " +
                            str([(at_2, at_1, at_3), (at_3, at_2, at_4)][idx])
                            + " is insufficiently nonlinear",
                        "XYZ file: " + self.XYZ_path))
            ## end if
        ## next idx

        # Store normalized atomic displacement vector at_2 --> at_3 as that
        #  defining the projection plane
        plane_norm = squeeze(np.array(self.Displ_single(g_num, at_2, at_3)))
        plane_norm = plane_norm / norm(plane_norm)

        # Retrieve the orthonormal basis in the projection plane, with the
        #  first vector being the normalized projection of the at_1 --> at_2
        #  displacement onto that plane
        on1, on2 = ortho_basis(plane_norm, \
                            self.Displ_single(g_num, at_1, at_2))

        # Convert on1 and on2 to squeezed np.arrays
        on1 = squeeze(np.array(on1))
        on2 = squeeze(np.array(on2))

        # Project the at_3 --> at_4 displacement onto the plane
        #
        # Retrieve the "back-side" displacement vector
        back_vec = squeeze(np.array(self.Displ_single(g_num, at_3, at_4)))

        # Project onto the plane by subtracting out the plane_norm projection
        #  and normalize
        back_vec = back_vec - (dot(back_vec, plane_norm) * plane_norm)
        back_vec /= norm(back_vec)

        # Calculate the absolute value of the departure of the dihedral/
        #  out-of-plane angle from 180 degrees as derived from the dot-product
        #  of on1 and back_vec. Both should be normalized at this point, so
        #  the calculation is straightforward
        dihed = degrees(arccos(dot(back_vec, on1)))

        # Given the handedness of the spanning vectors provided by ortho_basis,
        #  the sign of the dihed departure is that of the dot product
        #  of back_vec and on2.
        dihed *= sign(dot(back_vec, on2))

        # Conversion to the stated typical definition of a dihehdral now
        #  requires addition of 180 degrees.
        dihed += 180.0

        # Should be set to return the value
        return dihed


    def Dihed_iter(self, g_nums, ats_1, ats_2, ats_3, ats_4):
        """ Iterator over selected dihedral angles.

        Returns the out-of-plane angle among each group of four atoms ats_1,
            ats_2, ats_3 and ats_4 from the corresponding geometries g_nums,
            in degrees.  The reference planes are spanned by the ats_1, ats_2
            and ats_3. The out-of-plane angles are defined such that a positive
            angle represents a counter-clockwise rotation of the projected
            at_3 --> at_4 vector with respect to the reference plane when
            looking from at_3 toward at_2.  Zero rotation corresponds to
            occlusion of at_1 and at_4; that is, the case when the respective
            normalized projections of at_1 --> at_2 and at_3 --> at_4 onto
            the reference plane are ANTI-PARALLEL.

        All four atom indices must be distinct in each corresponding group.
            Both of the atom trios 1-2-3 and 2-3-4 must be sufficiently
            nonlinear, as diagnosed by a bend angle different from 0 or 180
            degrees by at least PRM.Non_Parallel_Tol.

        Parameters
        ----------
        g_nums   : int or iterable int
            Indices of the desired geometry (base 0)
        ats_1    : int or iterable int
            Indices of the first atoms (base 0)
        ats_2    : int or iterable int
            Indices of the second atoms (base 0)
        ats_3    : int or iterable int
            Indices of the third atoms (base 0)
        ats_4    : int or iterable int
            Indices of the fourth atoms (base 0)

        Returns
        -------
        dihed : np.float64 generator
            Out-of-plane/dihedral angles in degrees for the indicated atoms,
            drawn from g_nums

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_nums, or ats_n is provided

        ValueError : If any indices ats_n are equal within a group

        XYZError   : (typecode dihed) If either of the atom trios (1-2-3 or
            2-3-4) is too close to linearity for any group
        """
        # Suitability of ats_n indices will be checked within the
        #  self.Dihed_single() calls and thus no check is needed here.

        # Import the tuple-generating function
        from .utils import pack_tups

        # Print the function inputs if debug mode is on
        if _DEBUG:   # pragma: no cover
            print("g_nums = " + str(g_nums))
            print("ats_1 = " + str(ats_1))
            print("ats_2 = " + str(ats_2))
            print("ats_3 = " + str(ats_3))
            print("ats_4 = " + str(ats_4))
        ## end if

        # Expand/pack the tuples from the inputs
        tups = pack_tups(g_nums, ats_1, ats_2, ats_3, ats_4)

        # Dump the results if debug mode is on
        if _DEBUG:   # pragma: no cover
            print(tups)
        ## end if

        # Construct the generator using the packed tuples.
        for tup in tups:
            yield self.Dihed_single(*tup)
        ## next tup


    def Displ_single(self, g_num, at_1, at_2):
        """ Displacement vector between two atoms from an OPAN_XYZ instance.

        Returns the displacement vector pointing from at_1 toward at_2 from the
            indicated geometry. No check is made for whether at_1 == at_2;
            testing for a strict zero vector MAY NOT BE SUFFICIENT to detect
            at_1 == at_2.

        Displacement vector is returned in units of Bohrs.

        Parameters
        ----------
        g_num   : int
            Index of the desired geometry (base 0)
        at_1    : int
            Index of the first atom (base 0)
        at_2    : int
            Index of the second atom (base 0)

        Returns
        -------
        displ : (3,1) np.matrix of np.float64
            Displacement vector from at_1 to at_2

        Raises
        ------
        IndexError : If an invalid (out-of-range) g_num, or at_n is provided

        """

        # Library imports
        import numpy as np
        from numpy import floor

        # The below errors are explicitly thrown since they are multiplied by
        #  three when they are used as an index and thus give non-intuitive
        #  errors
        # Complain if at_1 is invalid
        if at_1 < -self.num_atoms or at_1 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_1' (" + str(at_1) + ")"))

        # Complain if at_2 is invalid
        if at_2 < -self.num_atoms or at_2 >= self.num_atoms:
            raise(IndexError("Invalid index for 'at_2' (" + str(at_2) + ")"))

        # Should never be necessary (save for badly erroneous calling code),
        #  but coerce at_1 and at_2 to their floor() values.  This is again
        #  needed since they are multiplied by three in the index expresssions
        #  below, and can cause funny behavior when truncated by the indexing
        at_1 = int(floor(at_1))
        at_2 = int(floor(at_2))

        # Retrieve the geometry; np.float64 type should be retained
        g = self.Geom_single(g_num)

        # Calculate the displacement vector and convert to (3,1) np.matrix
        displ = [ g[i + 3*at_2, 0] - g[i + 3*at_1, 0] for i in range(3) ]
        displ = np.matrix(displ).reshape((3,1))

        # Return the displacement vector
        return displ


    def Displ_iter(self, g_nums, ats_1, ats_2):
        """ Iterator over indicated displacement vectors.

        Returns the respective displacement vectors pointing from ats_1 toward
            ats_2 from the indicated geometries.

        Raised errors are those of Displ_single. Displacements are in Bohrs.

        Any of ats_1, ats_2 and g_nums can be either a single index or an
            iterable.

        Parameters
        ----------
        g_nums : int or iterable int
            Index/indices of the desired geometry/geometries (base 0)
        ats_1 : int or iterable int
            Index/indices of the first atom(s) (base 0)
        ats_2 : int or iterable int
            Index/indices of the second atom(s) (base 0)

        Returns
        -------
        displ : np.float64 (generator)
            Displacement vector in Bohrs between each atom pair of ats_1 and
            ats_2 from the corresponding geometries of g_nums.

        Raises
        ------
        ValueError :  (via orca_utils.pack_tups) If all iterable objects are
            not the same length

        """

        # Import the tuple-generating function
        from .utils import pack_tups

        # Print the function inputs if debug mode is on
        if _DEBUG:  # pragma: no cover
            print("g_nums = " + str(g_nums))
            print("ats_1 = " + str(ats_1))
            print("ats_2 = " + str(ats_2))
        ## end if

        # Expand/pack the tuples from the inputs
        tups = pack_tups(g_nums, ats_1, ats_2)

        # Dump the results if debug mode is on
        if _DEBUG:  # pragma: no cover
            print(tups)
        ## end if

        # Construct the generator using the packed tuples.
        for tup in tups:
            yield self.Displ_single(*tup)
        ## next tup


if __name__ == '__main__':  # pragma: no cover
    print("Module not executable")
